<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AnalysisUIOptions">
    <option name="SCOPE_TYPE" value="3" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="b0496aaa-cdd3-48da-9997-1a22298cde73" name="Default Changelist" comment="백준 11404번 플로이드 플로이드 워셜 문제&#10;&#10;플로이드 워셜 연습용 문제임. 그런데 약간 비틀어서 추정 예상되는 가장 큰 비용값으로 경로 배열을 초기화하지 않고 0으로 초기화 해놓고 플로이드 워셜을 썼음. 이것도 가능은 하네 ㅇㅅㅇ;;">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/out/production/Practicing-Java-and-Git/Main.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Practicing-Java-and-Git/Main.class" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/Main.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/Main.java" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="PUSH_AUTO_UPDATE" value="true" />
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GitSEFilterConfiguration">
    <file-type-list>
      <filtered-out-file-type name="LOCAL_BRANCH" />
      <filtered-out-file-type name="REMOTE_BRANCH" />
      <filtered-out-file-type name="TAG" />
      <filtered-out-file-type name="COMMIT_BY_MESSAGE" />
    </file-type-list>
  </component>
  <component name="MarkdownSettingsMigration">
    <option name="stateVersion" value="1" />
  </component>
  <component name="ProjectId" id="2135rX1w0HuR7RH1xN46edl6lh5" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
    <option name="showVisibilityIcons" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="ASKED_SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="last.edited.regexp" value="[1,3,4,5]" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/src/Queue/Card2.java" />
    <property name="project.structure.last.edited" value="모듈" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="run.code.analysis.last.selected.profile" value="pProject Default" />
    <property name="settings.editor.selected.configurable" value="preferences.keymap" />
    <property name="two.files.diff.last.used.file" value="$PROJECT_DIR$/src/Queue/Card2.java" />
  </component>
  <component name="RunManager" selected="애플리케이션.Main">
    <configuration name="FourSquare" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="DP.FourSquare" />
      <module name="Practicing-Java-and-Git" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="DP.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="LIS" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="DP.LIS" />
      <module name="untitled" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="DP.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="ALTERNATIVE_JRE_PATH" value="13" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="true" />
      <option name="MAIN_CLASS_NAME" value="Main" />
      <module name="Practicing-Java-and-Git" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="TreeDiameter" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="GraphTheory.DFSandBFS.TreeDiameter" />
      <module name="Practicing-Java-and-Git" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="GraphTheory.DFSandBFS.Dijkstra" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="TreeTraversal" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="GraphTheory.TreeTraversal" />
      <module name="Practicing-Java-and-Git" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="GraphTheory.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <list>
      <item itemvalue="애플리케이션.Main" />
      <item itemvalue="애플리케이션.LIS" />
      <item itemvalue="애플리케이션.TreeDiameter" />
      <item itemvalue="애플리케이션.FourSquare" />
      <item itemvalue="애플리케이션.TreeTraversal" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="애플리케이션.Main" />
        <item itemvalue="애플리케이션.TreeTraversal" />
        <item itemvalue="애플리케이션.FourSquare" />
        <item itemvalue="애플리케이션.TreeDiameter" />
        <item itemvalue="애플리케이션.LIS" />
      </list>
    </recent_temporary>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="b0496aaa-cdd3-48da-9997-1a22298cde73" name="Default Changelist" comment="" />
      <created>1637157129708</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1637157129708</updated>
    </task>
    <task id="LOCAL-00138" summary="백준 1043번 거짓말 그래프이론&#10;&#10;어떤 친구가 어떤 친구와 같은 집합에 속하는지 찾아내는 문제. 진실을 아는 친구들과 모르는 친구들을 구분해서 찾아내는게 기본이 되겠음.">
      <created>1665713469951</created>
      <option name="number" value="00138" />
      <option name="presentableId" value="LOCAL-00138" />
      <option name="project" value="LOCAL" />
      <updated>1665713469951</updated>
    </task>
    <task id="LOCAL-00139" summary="백준 1043번 거짓말 그래프이론&#10;&#10;어떤 친구가 어떤 친구와 같은 집합에 속하는지 찾아내는 문제. 진실을 아는 친구들과 모르는 친구들을 구분해서 찾아내는게 기본이 되겠음.&#10;&#10;union 함수는 자기와 같은 집합인지 판단해서 하나의 집합에 합쳐주는 역할임. 여기서 누가 진실을 아는지는 판단하지 않음. 여기서 판단했을 경우 역순으로 진실을 아는 사람이 나왔을때 대응할 수 가 없음.&#10;&#10;Find 함수가 진실을 알고있는 노드를 받아와서 자기와 같은 집합에 소속된 모든 노드에게 진실을 퍼뜨리는 역할을 해줌. 이 Find함수는 일종의 bfs로 처음 주어진 진실을 아는 노드가 들어가있는 큐에서 시작됨.">
      <created>1665713877469</created>
      <option name="number" value="00139" />
      <option name="presentableId" value="LOCAL-00139" />
      <option name="project" value="LOCAL" />
      <updated>1665713877469</updated>
    </task>
    <task id="LOCAL-00140" summary="하는 중&#10;&#10;12&#10;1 2 1 3 1 -1&#10;2 1 1 4 3 5 5 -1&#10;3 1 1 6 1 -1&#10;4 7 2 2 3 -1&#10;5 2 5 8 4 9 2 -1&#10;6 3 1 10 1 11 1 -1&#10;7 4 2 -1&#10;8 5 4 12 5 -1&#10;9 5 2 -1&#10;10 6 1 -1&#10;11 6 1 -1&#10;12 8 5 -1">
      <created>1665735452026</created>
      <option name="number" value="00140" />
      <option name="presentableId" value="LOCAL-00140" />
      <option name="project" value="LOCAL" />
      <updated>1665735452026</updated>
    </task>
    <task id="LOCAL-00141" summary="하는 중&#10;&#10;12&#10;1 2 1 3 1 -1&#10;2 1 1 4 3 5 5 -1&#10;3 1 1 6 1 -1&#10;4 7 2 2 3 -1&#10;5 2 5 8 4 9 2 -1&#10;6 3 1 10 1 11 1 -1&#10;7 4 2 -1&#10;8 5 4 12 5 -1&#10;9 5 2 -1&#10;10 6 1 -1&#10;11 6 1 -1&#10;12 8 5 -1">
      <created>1665994426130</created>
      <option name="number" value="00141" />
      <option name="presentableId" value="LOCAL-00141" />
      <option name="project" value="LOCAL" />
      <updated>1665994426132</updated>
    </task>
    <task id="LOCAL-00142" summary="백준 1167번 트리의 지름 dfs 문제&#10;&#10;어느 정점을 정해놓는다. 그 정점에서 제일 먼 정점을 구한다. 구한 정점에서 제일 먼 정점을 구한다 == 트리의 지름을 구했다. dfs 두 번으로 해결할 수 있는 문제다.&#10;문제는 dfs 함수 안에 visited = false를 쳐넣어놓는 실수를 해서 시간초과가 계속 떴다. 그래서 그냥 통째로 false로 바꿔줬더니 통과가 됐다.">
      <created>1666067865064</created>
      <option name="number" value="00142" />
      <option name="presentableId" value="LOCAL-00142" />
      <option name="project" value="LOCAL" />
      <updated>1666067865064</updated>
    </task>
    <task id="LOCAL-00143" summary="백준 1967번 트리의 지름 dfs 문제&#10;&#10;어느 정점을 정해놓는다. 그 정점에서 제일 먼 정점을 구한다. 구한 정점에서 제일 먼 정점을 구한다 == 트리의 지름을 구했다. dfs 두 번으로 해결할 수 있는 문제다.&#10;&#10;다른 트리 지름 문제 코드를 약간 바꿨음 == 날먹">
      <created>1666069112016</created>
      <option name="number" value="00143" />
      <option name="presentableId" value="LOCAL-00143" />
      <option name="project" value="LOCAL" />
      <updated>1666069112017</updated>
    </task>
    <task id="LOCAL-00144" summary="하는 중">
      <created>1666081092226</created>
      <option name="number" value="00144" />
      <option name="presentableId" value="LOCAL-00144" />
      <option name="project" value="LOCAL" />
      <updated>1666081092226</updated>
    </task>
    <task id="LOCAL-00145" summary="백준 1753번 최단거리 다익스트라 문제&#10;&#10;가장 단순한 다익스트라로 최단거리 구하기. 방향그래프인거 조심">
      <created>1666238683700</created>
      <option name="number" value="00145" />
      <option name="presentableId" value="LOCAL-00145" />
      <option name="project" value="LOCAL" />
      <updated>1666238683700</updated>
    </task>
    <task id="LOCAL-00146" summary="하는 중">
      <created>1666253649118</created>
      <option name="number" value="00146" />
      <option name="presentableId" value="LOCAL-00146" />
      <option name="project" value="LOCAL" />
      <updated>1666253649118</updated>
    </task>
    <task id="LOCAL-00147" summary="백준 1504번 특정한 최단 거리 그래프 문제&#10;&#10;일단 왔던 간선을 똑같이 또 갈 수 있다는 걸 이용해서 그냥 플로이드 워셜 알고리즘을 썼음. 쓰고나서 1 부터 n 까지의 경로를 a 와 b 를 들러가게끔 분할함.&#10;1 2 2 3 3 N&#10;1 2 2 3 2 N&#10;1 2 2 3 1 N&#10;&#10;1 3 3 2 1 N&#10;1 3 3 2 3 N&#10;1 3 3 2 2 N&#10;&#10;&#10;1 2 1 3 1 N &#10;1 2 1 3 3 N&#10;1 2 1 3 2 N&#10;&#10;2 = a, 3 = b 인 식임. 여기서 a 와 b 가 1과 n일 가능성도 있으므로 같은 정점으로 가는 (=움직이지 않는) 간선 길이는 0으로 만들어줘야함. 또 특정 정점을 방문하고 나서 그 정점에서 출발하는게 아니라면 돌아오는 간선 길이도 당연히 합산해야함.">
      <created>1666324691722</created>
      <option name="number" value="00147" />
      <option name="presentableId" value="LOCAL-00147" />
      <option name="project" value="LOCAL" />
      <updated>1666324691722</updated>
    </task>
    <task id="LOCAL-00148" summary="백준 1238번 파티 그래프 문제&#10;&#10;플로이드 워셜로 풀었음. 최소 x까지 길 + x에서 다시 원래 자리로 돌아오는 길의 합이 최대인 것을 구하면 됨. 코드가 간단한 대신 약간 느릴 수 있음&#10;&#10;다익스트라를 n번(각 정점마다 ) 쓰는것도 방법이겠음. &#10;&#10;좋은 의견 =&gt; 가상의 점(0,0을 쓰면 될듯)이 다른 모든 정점에 대해 가중치가 0인 간선을 가지고있다고 한다면 가상의 점에 대해 다익스트라를 사용할 경우 모든 정점에 대해 다익스트라를 하는거나 마찬가지가 될 수 있겠음. 따라서 총합 두번의 다익스트라로 문제를 풀 수는 있다고 함.">
      <created>1666331304301</created>
      <option name="number" value="00148" />
      <option name="presentableId" value="LOCAL-00148" />
      <option name="project" value="LOCAL" />
      <updated>1666331304301</updated>
    </task>
    <task id="LOCAL-00149" summary="벨만 포드로 들어가보자">
      <created>1666339784391</created>
      <option name="number" value="00149" />
      <option name="presentableId" value="LOCAL-00149" />
      <option name="project" value="LOCAL" />
      <updated>1666339784391</updated>
    </task>
    <task id="LOCAL-00150" summary="시간 초과 3연타 뭐냐고~~~~~">
      <created>1666599313579</created>
      <option name="number" value="00150" />
      <option name="presentableId" value="LOCAL-00150" />
      <option name="project" value="LOCAL" />
      <updated>1666599313579</updated>
    </task>
    <task id="LOCAL-00151" summary="백준 1865번 웜홀 벨만 포드 알고리즘&#10;&#10;자. 이 문제 야발이 하고싶은 말은 실제로 원래 자리로 돌아오고, 그게 시간이 얼마나 줄어드는지가 궁금한 것이냐? 절대 아니다. 즉 실제 값을 구할 수는 있지만, 구할 필요가 없고, 구할 경우 시간초과가 나게끔 되어있다. 그럼 문제가 물어보는 것이 뭐냐면 그래프 전체에 음의 사이클이 있냐 없냐이다. 사이클을 통해서 감소된 시간으로 원래 자리로 돌아올 수 있느냐를 묻고 싶은것. 즉 우리가 할것은 전체 그래프에 음의 사이클이 있냐 없냐만 찾아내면 된다.&#10;&#10;그러므로 bell(=dist)거리 배열을 전부 0으로 해놓고 벨만 포드를 돌렸을때. 음의 사이클이 있는지를 바로 찾을 수 있으므로 문제를 풀 수 있다. 만약 실제 거리를 묻는다면 각 정점에 대해 벨만 포드를 돌려야된다.">
      <created>1666843184883</created>
      <option name="number" value="00151" />
      <option name="presentableId" value="LOCAL-00151" />
      <option name="project" value="LOCAL" />
      <updated>1666843184883</updated>
    </task>
    <task id="LOCAL-00152" summary="하는중">
      <created>1666857979319</created>
      <option name="number" value="00152" />
      <option name="presentableId" value="LOCAL-00152" />
      <option name="project" value="LOCAL" />
      <updated>1666857979319</updated>
    </task>
    <task id="LOCAL-00153" summary="난 쓰레기야 이따위 코드로는 안돼">
      <created>1666939368202</created>
      <option name="number" value="00153" />
      <option name="presentableId" value="LOCAL-00153" />
      <option name="project" value="LOCAL" />
      <updated>1666939368202</updated>
    </task>
    <task id="LOCAL-00154" summary="백준 1107번 리모컨 브루트 포스&#10;&#10;이렇게 쉬운걸 이 지랄을 해서 풀었다니 믿기지가 않는다. 좀 더 쉽게 풀려다가 한참 돌아갔었음. 지금 알고리즘은 가고싶은 채널에서 + - next해가면서 그 값이 valid 한 값인지 검사하는 거임. 모든 자리 수가 다 입력가능한지 판단하는 간단한 알고리즘이지만 시간은 꽤 오래 걸릴것.. 좀 더 쉽게 할 방법이 없을까 해서 작을때 클때  구분해서 접근하는 방식으로 했었는데 결국 실패.">
      <created>1667272671745</created>
      <option name="number" value="00154" />
      <option name="presentableId" value="LOCAL-00154" />
      <option name="project" value="LOCAL" />
      <updated>1667272671745</updated>
    </task>
    <task id="LOCAL-00155" summary="백준 1107번 리모컨 브루트 포스&#10;&#10;이렇게 쉬운걸 이 지랄을 해서 풀었다니 믿기지가 않는다. 좀 더 쉽게 풀려다가 한참 돌아갔었음. 지금 알고리즘은 가고싶은 채널에서 + - next해가면서 그 값이 valid 한 값인지 검사하는 거임. 모든 자리 수가 다 입력가능한지 판단하는 간단한 알고리즘이지만 시간은 꽤 오래 걸릴것.. 좀 더 쉽게 할 방법이 없을까 해서 작을때 클때  구분해서 접근하는 방식으로 했었는데 결국 실패.">
      <created>1667273047134</created>
      <option name="number" value="00155" />
      <option name="presentableId" value="LOCAL-00155" />
      <option name="project" value="LOCAL" />
      <updated>1667273047134</updated>
    </task>
    <task id="LOCAL-00156" summary="메모리 초과 오지게 뜸.">
      <created>1667290531015</created>
      <option name="number" value="00156" />
      <option name="presentableId" value="LOCAL-00156" />
      <option name="project" value="LOCAL" />
      <updated>1667290531015</updated>
    </task>
    <task id="LOCAL-00157" summary="백준 9019번 DSLR 그래프 문제&#10;&#10;굉장히 많은 우여곡절을 거친 문제. 일단 먼저 BFS사용을 하는건 맞음. 그런데 인수로 문자열을 넘겨주는게 문제가 됨.  따라서 문자열을 넘겨주지 않고 부모를 쫒아가게끔 만들었음. 다음은 방문 배열임. 이 방문 배열은 문자열이 아니라(문자열은 절대 중복으로 안나옴) 메소드를 거친 결과 숫자가 됨. 왜냐면 이미 거쳐간 수는 다시 DSLR할 필요가 없으므로. 이걸로 메모리 초과는 해결. 문제는 시간초과가 계속 떴음. &#10;거기서 깨달음. L과 R 을 스트링빌더로 만들어서 겁나 시간 낭비가 오졌던 거였음. 그래서 메소드 새로 짜서 통과">
      <created>1667359621040</created>
      <option name="number" value="00157" />
      <option name="presentableId" value="LOCAL-00157" />
      <option name="project" value="LOCAL" />
      <updated>1667359621041</updated>
    </task>
    <task id="LOCAL-00158" summary="백준 10026번 적록색약 그래프 문제&#10;&#10;BFS 두번 돌려도 시간초과 안남! 처음 BFS를 돌리면서 R,G,B 구역이 총 몇개 있는지를 찾아냄. 그러면서 동시에 G를 R로 바꿔줌. 그 다음 BFS를 한번 더 돌리면 (R +G ), B의 구역을 찾아낼 수 있음.">
      <created>1667371364122</created>
      <option name="number" value="00158" />
      <option name="presentableId" value="LOCAL-00158" />
      <option name="project" value="LOCAL" />
      <updated>1667371364122</updated>
    </task>
    <task id="LOCAL-00159" summary="백준 14500번 테트로미노 브루트포스 문제&#10;&#10;일단 정사각형 4개 붙이는건 19가지 방식이 있다고 함. 일단 dfs를 써서 어떤 한 점을 시작으로 하는 도형들은 싹다 커버 가능. 그 다음은 점 기준 사방면 중에서 3개를 고르는 것 (뻐큐모양) 이렇게로 전부 커버가 가능함. 이걸 모든 점에 대해서 다 돌리면 해결 가능.">
      <created>1667457256441</created>
      <option name="number" value="00159" />
      <option name="presentableId" value="LOCAL-00159" />
      <option name="project" value="LOCAL" />
      <updated>1667457256441</updated>
    </task>
    <task id="LOCAL-00160" summary="하는중">
      <created>1667463065316</created>
      <option name="number" value="00160" />
      <option name="presentableId" value="LOCAL-00160" />
      <option name="project" value="LOCAL" />
      <updated>1667463065316</updated>
    </task>
    <task id="LOCAL-00161" summary="백준 11403번 경로 찾기 플로이드 워셜 문제&#10;&#10;그냥 플로이드 워셜로 현재 0인 경로에다가 깔쌈하게 적용해주면 됨.">
      <created>1667535255505</created>
      <option name="number" value="00161" />
      <option name="presentableId" value="LOCAL-00161" />
      <option name="project" value="LOCAL" />
      <updated>1667535255505</updated>
    </task>
    <task id="LOCAL-00162" summary="백준 11727번 2*n 타일링 2 dp문제&#10;&#10;처음에 l 작대기를 그으면 = dp[n -1];&#10;처음에 = , ㅁ 두개 긋고 = 2 * dp[n -2];&#10;&#10;간단.">
      <created>1667538969713</created>
      <option name="number" value="00162" />
      <option name="presentableId" value="LOCAL-00162" />
      <option name="project" value="LOCAL" />
      <updated>1667538969713</updated>
    </task>
    <task id="LOCAL-00163" summary="하는중">
      <created>1667546184379</created>
      <option name="number" value="00163" />
      <option name="presentableId" value="LOCAL-00163" />
      <option name="project" value="LOCAL" />
      <updated>1667546184379</updated>
    </task>
    <task id="LOCAL-00164" summary="백준 16236번 아기 상어 bfs 문제&#10;&#10;일단 bfs로 가능한 물고기 찾고 먹고 다시 bfs를 계속 반복하는게 알고리즘.&#10;&#10;문제는 상어보다 큰 물고기 통과 못하게하는 코드를 잘 짜야되고,&#10;처음 Findfish를 돌릴때의 이중 for문이 잘 break되는지도 판단해야함.(break하나만 썼다가 틀렸음)">
      <created>1667796787290</created>
      <option name="number" value="00164" />
      <option name="presentableId" value="LOCAL-00164" />
      <option name="project" value="LOCAL" />
      <updated>1667796787290</updated>
    </task>
    <task id="LOCAL-00165" summary="백준 16928번 뱀과 사다리 게임 bfs 문제&#10;&#10;뱀과 사다리는 만약 있다면 무조건 타야됨. 탔을때 방문 체크는 하지 않아야함(더 줄어들 수 있음)(그런데 해도 괜찮을거 같기도 하고). 또 사다리의 목적지가 동일한 곳일 수 있음. -&gt; 그냥 큐가 아니라 우선순위 큐로 목적지에 도달 후에 바로 주사위를 굴릴 수 있게끔 하는게 좋겠음. 아니면 사다리 + 주사위값을 넣든지 해야함.">
      <created>1667801892539</created>
      <option name="number" value="00165" />
      <option name="presentableId" value="LOCAL-00165" />
      <option name="project" value="LOCAL" />
      <updated>1667801892540</updated>
    </task>
    <task id="LOCAL-00166" summary="백준 17219번 비밀번호 찾기 해시 문제&#10;&#10;아니 사람이 친절하게 해시 구현을 했으면 넘어가야지 이걸 틀리네 ㅋㅋ;&#10;해시맵으로 날먹함.">
      <created>1667804930864</created>
      <option name="number" value="00166" />
      <option name="presentableId" value="LOCAL-00166" />
      <option name="project" value="LOCAL" />
      <updated>1667804930864</updated>
    </task>
    <task id="LOCAL-00167" summary="하는중">
      <created>1667808708737</created>
      <option name="number" value="00167" />
      <option name="presentableId" value="LOCAL-00167" />
      <option name="project" value="LOCAL" />
      <updated>1667808708737</updated>
    </task>
    <task id="LOCAL-00168" summary="백준 17626번 FourSquare dp문제&#10;&#10;라그랑주의 네 제곱수 정리임. 일단 제곱수들은 전부 1이고, 제곱수가 아닌 친구들은 어떻게 구하느냐. 특정 수의 두배인 친구는 두배. 특정 수에 제곱수를 더한 값 이렇게 해서 구했는데 어찌저찌 통과는 됐음.">
      <created>1667880744851</created>
      <option name="number" value="00168" />
      <option name="presentableId" value="LOCAL-00168" />
      <option name="project" value="LOCAL" />
      <updated>1667880744851</updated>
    </task>
    <task id="LOCAL-00169" summary="하는중">
      <created>1667894862962</created>
      <option name="number" value="00169" />
      <option name="presentableId" value="LOCAL-00169" />
      <option name="project" value="LOCAL" />
      <updated>1667894862962</updated>
    </task>
    <task id="LOCAL-00170" summary="하는중">
      <created>1667981702122</created>
      <option name="number" value="00170" />
      <option name="presentableId" value="LOCAL-00170" />
      <option name="project" value="LOCAL" />
      <updated>1667981702122</updated>
    </task>
    <task id="LOCAL-00171" summary="하는중">
      <created>1668067389989</created>
      <option name="number" value="00171" />
      <option name="presentableId" value="LOCAL-00171" />
      <option name="project" value="LOCAL" />
      <updated>1668067389989</updated>
    </task>
    <task id="LOCAL-00172" summary="백준 1918번 후위표기식 스택 문제&#10;&#10;들어오는 연산자들을 우선순위를 매긴다. */ 는 +-보다 우선순위가 높고, 괄호는 최우선이므로 최대 연산길이 100을 우선순위에 더해준다. 만약 다음 연산자가 현재 연산자 스택의 맨 위 보다 우선순위가 낮다면, 그 우선순위까지의 연산을 모두 실행한다(pop해준다). 피연산자들은 그냥 바로 result스택에 넣어도 된다.">
      <created>1668137120439</created>
      <option name="number" value="00172" />
      <option name="presentableId" value="LOCAL-00172" />
      <option name="project" value="LOCAL" />
      <updated>1668137120439</updated>
    </task>
    <task id="LOCAL-00173" summary="백준 1991번 트리 순회 그래프 문제&#10;&#10;전위(preorder)  = 루트 - 왼 - 오&#10;중위(inorder) = 왼 - 루트 - 오&#10;후위(postorder) = 왼 - 오 - 루트&#10;&#10;재귀함수 3개 만듦">
      <created>1668146396231</created>
      <option name="number" value="00173" />
      <option name="presentableId" value="LOCAL-00173" />
      <option name="project" value="LOCAL" />
      <updated>1668146396231</updated>
    </task>
    <task id="LOCAL-00174" summary="하는중">
      <created>1668151705594</created>
      <option name="number" value="00174" />
      <option name="presentableId" value="LOCAL-00174" />
      <option name="project" value="LOCAL" />
      <updated>1668151705594</updated>
    </task>
    <task id="LOCAL-00175" summary="하는중">
      <created>1668413440591</created>
      <option name="number" value="00175" />
      <option name="presentableId" value="LOCAL-00175" />
      <option name="project" value="LOCAL" />
      <updated>1668413440591</updated>
    </task>
    <task id="LOCAL-00176" summary="하는중">
      <created>1668499776387</created>
      <option name="number" value="00176" />
      <option name="presentableId" value="LOCAL-00176" />
      <option name="project" value="LOCAL" />
      <updated>1668499776387</updated>
    </task>
    <task id="LOCAL-00177" summary="조금만 더 하면 될거같다.">
      <created>1668586799420</created>
      <option name="number" value="00177" />
      <option name="presentableId" value="LOCAL-00177" />
      <option name="project" value="LOCAL" />
      <updated>1668586799420</updated>
    </task>
    <task id="LOCAL-00178" summary="백준 2263번 트리의 순회 트리 문제&#10;&#10;in, postorder로 주어진 순회로 pre오더를 찾는것. 기본 알고리즘은 다음과 같다.&#10;&#10;post의 마지막 요소 값이 root가 된다.&#10;in에서 root의 위치를 찾으면, root보다 낮은 인덱스는 left subtree이고, 높은 인덱스는 right subtree이다.&#10;&#10;를 재귀적으로 반복하면 pre오더로 순회값을 구할 수 있다. 처음에는 실제 트리를 만들었는데, 굳이 그럴 필요는 없으므로 출력만 해주는걸로 바꿨다. 재귀도 많이 고쳤다. 함수 내에서 왼, 오 루트를 골라줬는데 그러지 않게 바꿨다. 그 다음 &#10;알고리즘의 두 번째 단계인 inorder에서 root의 위치 찾기에서 반복문이 너무 많이 돈다. 최악의 경우 n이 n번 돌기때문에 시간초과를 뿜어낸다. 요소의 중복이 없고, 원래 있는 index값이 변화하지도 않기때문에 hashmap으로 string을 넣어 원래 index를 반환하게 만들었다.">
      <created>1668754234904</created>
      <option name="number" value="00178" />
      <option name="presentableId" value="LOCAL-00178" />
      <option name="project" value="LOCAL" />
      <updated>1668754234904</updated>
    </task>
    <task id="LOCAL-00179" summary="하는중">
      <created>1668759162352</created>
      <option name="number" value="00179" />
      <option name="presentableId" value="LOCAL-00179" />
      <option name="project" value="LOCAL" />
      <updated>1668759162352</updated>
    </task>
    <task id="LOCAL-00180" summary="하는중">
      <created>1669018196950</created>
      <option name="number" value="00180" />
      <option name="presentableId" value="LOCAL-00180" />
      <option name="project" value="LOCAL" />
      <updated>1669018196951</updated>
    </task>
    <task id="LOCAL-00181" summary="하는중">
      <created>1669104958752</created>
      <option name="number" value="00181" />
      <option name="presentableId" value="LOCAL-00181" />
      <option name="project" value="LOCAL" />
      <updated>1669104958752</updated>
    </task>
    <task id="LOCAL-00182" summary="백준 2206번 벽 부수고 이동하기 bfs문제&#10;&#10;처음에는 단순한 bfs로 했는데 실패. 문제가 벽을 뚫을 수 있으면 다 뚫어봐야됨. 그래서 뭔 생각을 했냐면 for문 돌려서 벽이 나올때마다 벽에서 bfs를 돌리자 =&gt;개같이 실패. 그 다음은 스타트 지점에서 bfs를 돌리면서 가다가, 벽이 나오면 벽에서 bfs를 해서 목적지에 도달할 수 있는지 재귀로 판단하자 -&gt; 개같이 시간초과. 생각만 한거는 방문을 벽을 뚫음 = 1, 안뚫음 = 0 으로 해서 bfs가 두개 돌아가게 만들자고 생각했는데 방법을 고민하다가 너무 복잡한거 같아서 포기함. &#10;결론적으로 마지막이 정답. 그런데 구현방법을 새로운 클래스를 정의한다든지가 아니라, 삼차원 배열을 써서 z값을 벽을 부쉈나 안부쉈나로 판단했음. 간단히 해결됨.">
      <created>1669168877441</created>
      <option name="number" value="00182" />
      <option name="presentableId" value="LOCAL-00182" />
      <option name="project" value="LOCAL" />
      <updated>1669168877441</updated>
    </task>
    <task id="LOCAL-00183" summary="백준 2407번 조합 정수론&#10;&#10;100c50이 너무 크긴 함. 문자열으로 계산하면 됨. 개같이 빅---인트">
      <created>1669176689499</created>
      <option name="number" value="00183" />
      <option name="presentableId" value="LOCAL-00183" />
      <option name="project" value="LOCAL" />
      <updated>1669176689499</updated>
    </task>
    <task id="LOCAL-00184" summary="하는중">
      <created>1669190881998</created>
      <option name="number" value="00184" />
      <option name="presentableId" value="LOCAL-00184" />
      <option name="project" value="LOCAL" />
      <updated>1669190881998</updated>
    </task>
    <task id="LOCAL-00185" summary="백준 9465번 스티커 dp문제&#10;&#10;스티커를 뽑을 때, j - 1위치에서 사선에 위치한 j 스티커를 뽑을 수도있고,&#10;&#10;j -2 위치에서 어느 위치든 j 스티커를 뽑을 수 있다(위 아래 둘 다 선택 가능)&#10;&#10;따라서 dp[i][j] = max(dp[i - 1][j-1] , dp[i - 1][j - 2], dp[i][j - 2] + sticker[i][j]점화식이 나오게된다.">
      <created>1669255232406</created>
      <option name="number" value="00185" />
      <option name="presentableId" value="LOCAL-00185" />
      <option name="project" value="LOCAL" />
      <updated>1669255232406</updated>
    </task>
    <task id="LOCAL-00186" summary="백준 11404번 플로이드 플로이드 워셜 문제&#10;&#10;플로이드 워셜 연습용 문제임. 그런데 약간 비틀어서 추정 예상되는 가장 큰 비용값으로 경로 배열을 초기화하지 않고 0으로 초기화 해놓고 플로이드 워셜을 썼음. 이것도 가능은 하네 ㅇㅅㅇ;;">
      <created>1669264742735</created>
      <option name="number" value="00186" />
      <option name="presentableId" value="LOCAL-00186" />
      <option name="project" value="LOCAL" />
      <updated>1669264742735</updated>
    </task>
    <option name="localTasksCounter" value="187" />
    <servers />
  </component>
  <component name="Vcs.Log.History.Properties">
    <option name="COLUMN_ID_ORDER">
      <list>
        <option value="Default.Root" />
        <option value="Default.Author" />
        <option value="Default.Date" />
        <option value="Default.Subject" />
        <option value="Space.CommitStatus" />
      </list>
    </option>
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="FILTERS">
                <map>
                  <entry key="branch">
                    <value>
                      <list>
                        <option value="main" />
                      </list>
                    </value>
                  </entry>
                </map>
              </option>
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
  <component name="VcsManagerConfiguration">
    <option name="CHECK_NEW_TODO" value="false" />
    <MESSAGE value="백준 1238번 파티 그래프 문제&#10;&#10;플로이드 워셜로 풀었음. 최소 x까지 길 + x에서 다시 원래 자리로 돌아오는 길의 합이 최대인 것을 구하면 됨. 코드가 간단한 대신 약간 느릴 수 있음&#10;&#10;다익스트라를 n번(각 정점마다 ) 쓰는것도 방법이겠음. &#10;&#10;좋은 의견 =&gt; 가상의 점(0,0을 쓰면 될듯)이 다른 모든 정점에 대해 가중치가 0인 간선을 가지고있다고 한다면 가상의 점에 대해 다익스트라를 사용할 경우 모든 정점에 대해 다익스트라를 하는거나 마찬가지가 될 수 있겠음. 따라서 총합 두번의 다익스트라로 문제를 풀 수는 있다고 함." />
    <MESSAGE value="벨만 포드로 들어가보자" />
    <MESSAGE value="시간 초과 3연타 뭐냐고~~~~~" />
    <MESSAGE value="백준 1865번 웜홀 벨만 포드 알고리즘&#10;&#10;자. 이 문제 야발이 하고싶은 말은 실제로 원래 자리로 돌아오고, 그게 시간이 얼마나 줄어드는지가 궁금한 것이냐? 절대 아니다. 즉 실제 값을 구할 수는 있지만, 구할 필요가 없고, 구할 경우 시간초과가 나게끔 되어있다. 그럼 문제가 물어보는 것이 뭐냐면 그래프 전체에 음의 사이클이 있냐 없냐이다. 사이클을 통해서 감소된 시간으로 원래 자리로 돌아올 수 있느냐를 묻고 싶은것. 즉 우리가 할것은 전체 그래프에 음의 사이클이 있냐 없냐만 찾아내면 된다.&#10;&#10;그러므로 bell(=dist)거리 배열을 전부 0으로 해놓고 벨만 포드를 돌렸을때. 음의 사이클이 있는지를 바로 찾을 수 있으므로 문제를 풀 수 있다. 만약 실제 거리를 묻는다면 각 정점에 대해 벨만 포드를 돌려야된다." />
    <MESSAGE value="난 쓰레기야 이따위 코드로는 안돼" />
    <MESSAGE value="백준 1107번 리모컨 브루트 포스&#10;&#10;이렇게 쉬운걸 이 지랄을 해서 풀었다니 믿기지가 않는다. 좀 더 쉽게 풀려다가 한참 돌아갔었음. 지금 알고리즘은 가고싶은 채널에서 + - next해가면서 그 값이 valid 한 값인지 검사하는 거임. 모든 자리 수가 다 입력가능한지 판단하는 간단한 알고리즘이지만 시간은 꽤 오래 걸릴것.. 좀 더 쉽게 할 방법이 없을까 해서 작을때 클때  구분해서 접근하는 방식으로 했었는데 결국 실패." />
    <MESSAGE value="메모리 초과 오지게 뜸." />
    <MESSAGE value="백준 9019번 DSLR 그래프 문제&#10;&#10;굉장히 많은 우여곡절을 거친 문제. 일단 먼저 BFS사용을 하는건 맞음. 그런데 인수로 문자열을 넘겨주는게 문제가 됨.  따라서 문자열을 넘겨주지 않고 부모를 쫒아가게끔 만들었음. 다음은 방문 배열임. 이 방문 배열은 문자열이 아니라(문자열은 절대 중복으로 안나옴) 메소드를 거친 결과 숫자가 됨. 왜냐면 이미 거쳐간 수는 다시 DSLR할 필요가 없으므로. 이걸로 메모리 초과는 해결. 문제는 시간초과가 계속 떴음. &#10;거기서 깨달음. L과 R 을 스트링빌더로 만들어서 겁나 시간 낭비가 오졌던 거였음. 그래서 메소드 새로 짜서 통과" />
    <MESSAGE value="백준 10026번 적록색약 그래프 문제&#10;&#10;BFS 두번 돌려도 시간초과 안남! 처음 BFS를 돌리면서 R,G,B 구역이 총 몇개 있는지를 찾아냄. 그러면서 동시에 G를 R로 바꿔줌. 그 다음 BFS를 한번 더 돌리면 (R +G ), B의 구역을 찾아낼 수 있음." />
    <MESSAGE value="백준 14500번 테트로미노 브루트포스 문제&#10;&#10;일단 정사각형 4개 붙이는건 19가지 방식이 있다고 함. 일단 dfs를 써서 어떤 한 점을 시작으로 하는 도형들은 싹다 커버 가능. 그 다음은 점 기준 사방면 중에서 3개를 고르는 것 (뻐큐모양) 이렇게로 전부 커버가 가능함. 이걸 모든 점에 대해서 다 돌리면 해결 가능." />
    <MESSAGE value="백준 11403번 경로 찾기 플로이드 워셜 문제&#10;&#10;그냥 플로이드 워셜로 현재 0인 경로에다가 깔쌈하게 적용해주면 됨." />
    <MESSAGE value="백준 11727번 2*n 타일링 2 dp문제&#10;&#10;처음에 l 작대기를 그으면 = dp[n -1];&#10;처음에 = , ㅁ 두개 긋고 = 2 * dp[n -2];&#10;&#10;간단." />
    <MESSAGE value="백준 16236번 아기 상어 bfs 문제&#10;&#10;일단 bfs로 가능한 물고기 찾고 먹고 다시 bfs를 계속 반복하는게 알고리즘.&#10;&#10;문제는 상어보다 큰 물고기 통과 못하게하는 코드를 잘 짜야되고,&#10;처음 Findfish를 돌릴때의 이중 for문이 잘 break되는지도 판단해야함.(break하나만 썼다가 틀렸음)" />
    <MESSAGE value="백준 16928번 뱀과 사다리 게임 bfs 문제&#10;&#10;뱀과 사다리는 만약 있다면 무조건 타야됨. 탔을때 방문 체크는 하지 않아야함(더 줄어들 수 있음)(그런데 해도 괜찮을거 같기도 하고). 또 사다리의 목적지가 동일한 곳일 수 있음. -&gt; 그냥 큐가 아니라 우선순위 큐로 목적지에 도달 후에 바로 주사위를 굴릴 수 있게끔 하는게 좋겠음. 아니면 사다리 + 주사위값을 넣든지 해야함." />
    <MESSAGE value="백준 17219번 비밀번호 찾기 해시 문제&#10;&#10;아니 사람이 친절하게 해시 구현을 했으면 넘어가야지 이걸 틀리네 ㅋㅋ;&#10;해시맵으로 날먹함." />
    <MESSAGE value="백준 17626번 FourSquare dp문제&#10;&#10;라그랑주의 네 제곱수 정리임. 일단 제곱수들은 전부 1이고, 제곱수가 아닌 친구들은 어떻게 구하느냐. 특정 수의 두배인 친구는 두배. 특정 수에 제곱수를 더한 값 이렇게 해서 구했는데 어찌저찌 통과는 됐음." />
    <MESSAGE value="백준 1918번 후위표기식 스택 문제&#10;&#10;들어오는 연산자들을 우선순위를 매긴다. */ 는 +-보다 우선순위가 높고, 괄호는 최우선이므로 최대 연산길이 100을 우선순위에 더해준다. 만약 다음 연산자가 현재 연산자 스택의 맨 위 보다 우선순위가 낮다면, 그 우선순위까지의 연산을 모두 실행한다(pop해준다). 피연산자들은 그냥 바로 result스택에 넣어도 된다." />
    <MESSAGE value="백준 1991번 트리 순회 그래프 문제&#10;&#10;전위(preorder)  = 루트 - 왼 - 오&#10;중위(inorder) = 왼 - 루트 - 오&#10;후위(postorder) = 왼 - 오 - 루트&#10;&#10;재귀함수 3개 만듦" />
    <MESSAGE value="조금만 더 하면 될거같다." />
    <MESSAGE value="백준 2263번 트리의 순회 트리 문제&#10;&#10;in, postorder로 주어진 순회로 pre오더를 찾는것. 기본 알고리즘은 다음과 같다.&#10;&#10;post의 마지막 요소 값이 root가 된다.&#10;in에서 root의 위치를 찾으면, root보다 낮은 인덱스는 left subtree이고, 높은 인덱스는 right subtree이다.&#10;&#10;를 재귀적으로 반복하면 pre오더로 순회값을 구할 수 있다. 처음에는 실제 트리를 만들었는데, 굳이 그럴 필요는 없으므로 출력만 해주는걸로 바꿨다. 재귀도 많이 고쳤다. 함수 내에서 왼, 오 루트를 골라줬는데 그러지 않게 바꿨다. 그 다음 &#10;알고리즘의 두 번째 단계인 inorder에서 root의 위치 찾기에서 반복문이 너무 많이 돈다. 최악의 경우 n이 n번 돌기때문에 시간초과를 뿜어낸다. 요소의 중복이 없고, 원래 있는 index값이 변화하지도 않기때문에 hashmap으로 string을 넣어 원래 index를 반환하게 만들었다." />
    <MESSAGE value="백준 2206번 벽 부수고 이동하기 bfs문제&#10;&#10;처음에는 단순한 bfs로 했는데 실패. 문제가 벽을 뚫을 수 있으면 다 뚫어봐야됨. 그래서 뭔 생각을 했냐면 for문 돌려서 벽이 나올때마다 벽에서 bfs를 돌리자 =&gt;개같이 실패. 그 다음은 스타트 지점에서 bfs를 돌리면서 가다가, 벽이 나오면 벽에서 bfs를 해서 목적지에 도달할 수 있는지 재귀로 판단하자 -&gt; 개같이 시간초과. 생각만 한거는 방문을 벽을 뚫음 = 1, 안뚫음 = 0 으로 해서 bfs가 두개 돌아가게 만들자고 생각했는데 방법을 고민하다가 너무 복잡한거 같아서 포기함. &#10;결론적으로 마지막이 정답. 그런데 구현방법을 새로운 클래스를 정의한다든지가 아니라, 삼차원 배열을 써서 z값을 벽을 부쉈나 안부쉈나로 판단했음. 간단히 해결됨." />
    <MESSAGE value="백준 2407번 조합 정수론&#10;&#10;100c50이 너무 크긴 함. 문자열으로 계산하면 됨. 개같이 빅---인트" />
    <MESSAGE value="하는중" />
    <MESSAGE value="백준 9465번 스티커 dp문제&#10;&#10;스티커를 뽑을 때, j - 1위치에서 사선에 위치한 j 스티커를 뽑을 수도있고,&#10;&#10;j -2 위치에서 어느 위치든 j 스티커를 뽑을 수 있다(위 아래 둘 다 선택 가능)&#10;&#10;따라서 dp[i][j] = max(dp[i - 1][j-1] , dp[i - 1][j - 2], dp[i][j - 2] + sticker[i][j]점화식이 나오게된다." />
    <MESSAGE value="백준 11404번 플로이드 플로이드 워셜 문제&#10;&#10;플로이드 워셜 연습용 문제임. 그런데 약간 비틀어서 추정 예상되는 가장 큰 비용값으로 경로 배열을 초기화하지 않고 0으로 초기화 해놓고 플로이드 워셜을 썼음. 이것도 가능은 하네 ㅇㅅㅇ;;" />
    <option name="LAST_COMMIT_MESSAGE" value="백준 11404번 플로이드 플로이드 워셜 문제&#10;&#10;플로이드 워셜 연습용 문제임. 그런데 약간 비틀어서 추정 예상되는 가장 큰 비용값으로 경로 배열을 초기화하지 않고 0으로 초기화 해놓고 플로이드 워셜을 썼음. 이것도 가능은 하네 ㅇㅅㅇ;;" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <breakpoint enabled="true" type="java-exception">
          <properties class="java.lang.ArrayIndexOutOfBoundsException" package="java.lang" />
          <option name="timeStamp" value="1" />
        </breakpoint>
        <breakpoint enabled="true" type="java-exception">
          <properties class="java.util.InputMismatchException" package="java.util" />
          <option name="timeStamp" value="2" />
        </breakpoint>
        <breakpoint enabled="true" type="java-exception">
          <properties class="java.lang.ArithmeticException" package="java.lang" />
          <option name="timeStamp" value="3" />
        </breakpoint>
        <breakpoint enabled="true" type="java-exception">
          <properties class="java.lang.IndexOutOfBoundsException" package="java.lang" />
          <option name="timeStamp" value="34" />
        </breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/DP/BitonicLis.java</url>
          <line>28</line>
          <option name="timeStamp" value="40" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/DP/BitonicLis.java</url>
          <line>22</line>
          <option name="timeStamp" value="41" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/DP/LIS.java</url>
          <line>22</line>
          <option name="timeStamp" value="103" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/DP/Tileing2.java</url>
          <line>13</line>
          <option name="timeStamp" value="135" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/Main.java</url>
          <line>20</line>
          <option name="timeStamp" value="167" />
        </line-breakpoint>
      </breakpoints>
    </breakpoint-manager>
    <watches-manager>
      <configuration name="Application">
        <watch expression="com[2]" />
        <watch expression="m" />
        <watch expression="tree[0]" language="JAVA" />
        <watch expression="((dslr)((LinkedList)bs).get(4)).num" custom="dslr,java.util.LinkedList" />
        <watch expression="bs" />
        <watch expression="oper.get(0).op" />
        <watch expression="tree[0]" language="JAVA" />
        <watch expression="root" />
      </configuration>
    </watches-manager>
  </component>
  <component name="com.intellij.coverage.CoverageDataManagerImpl">
    <SUITE FILE_PATH="coverage/Practicing_Java_and_Git$Main.ic" NAME="Main 커버리지 결과" MODIFIED="1668499518933" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" />
    <SUITE FILE_PATH="coverage/untitled$Main.ic" NAME="Main 커버리지 결과" MODIFIED="1653019956093" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" />
  </component>
</project>